import { EventEmitter } from 'events';
import { createConnection } from 'net';
import { createSocket } from 'dgram';
import { Buffer } from 'buffer';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var PacketType = {
  COMMAND: 0x02,
  AUTH: 0x03,
  RESPONSE_VALUE: 0x00,
  RESPONSE_AUTH: 0x02
};
var Rcon = /*#__PURE__*/function (_events$EventEmitter) {
  _inheritsLoose(Rcon, _events$EventEmitter);

  function Rcon(host, port, password, options) {
    var _this;

    _this = _events$EventEmitter.call(this) || this;

    _this.send = function (data, cmd, id) {
      var sendBuf;

      if (_this.tcp) {
        cmd = cmd || PacketType.COMMAND;
        id = id || _this.rconId;
        var length = Buffer.byteLength(data);
        sendBuf = Buffer.alloc(length + 14);
        sendBuf.writeInt32LE(length + 10, 0);
        sendBuf.writeInt32LE(id, 4);
        sendBuf.writeInt32LE(cmd, 8);
        sendBuf.write(data, 12);
        sendBuf.writeInt16LE(0, length + 12);
      } else {
        if (_this.challenge && !_this._challengeToken) {
          _this.emit('error', new Error('Not authenticated'));

          return;
        }

        var str = 'rcon ';
        if (_this._challengeToken) str += _this._challengeToken + ' ';
        if (_this.password) str += _this.password + ' ';
        str += data + '\n';
        sendBuf = Buffer.alloc(4 + Buffer.byteLength(str));
        sendBuf.writeInt32LE(-1, 0);
        sendBuf.write(str, 4);
      }

      _this._sendSocket(sendBuf);
    };

    _this._sendSocket = function (buf) {
      if (_this._tcpSocket) {
        _this._tcpSocket.write(buf.toString('binary'), 'binary');
      } else if (_this._udpSocket) {
        _this._udpSocket.send(buf, 0, buf.length, _this.port, _this.host);
      }
    };

    _this.connect = function () {
      if (_this.tcp) {
        _this._tcpSocket = createConnection(_this.port, _this.host);

        _this._tcpSocket.on('data', function (data) {
          _this._tcpSocketOnData(data);
        }).on('connect', function () {
          _this.socketOnConnect();
        }).on('error', function (err) {
          _this.emit('error', err);
        }).on('end', function () {
          _this.socketOnEnd();
        });
      } else {
        _this._udpSocket = createSocket('udp4');

        _this._udpSocket.on('message', function (data) {
          _this._udpSocketOnData(data);
        }).on('listening', function () {
          _this.socketOnConnect();
        }).on('error', function (err) {
          _this.emit('error', err);
        }).on('close', function () {
          _this.socketOnEnd();
        });

        _this._udpSocket.bind(0);
      }
    };

    _this.disconnect = function () {
      if (_this._tcpSocket) _this._tcpSocket.end();
      if (_this._udpSocket) _this._udpSocket.close();
    };

    _this.setTimeout = function (timeout, callback) {
      if (!_this._tcpSocket) return;

      _this._tcpSocket.setTimeout(timeout, function () {
        _this._tcpSocket.end();

        if (callback) callback();
      });
    };

    _this._udpSocketOnData = function (data) {
      var a = data.readUInt32LE(0);

      if (a === 0xffffffff) {
        var str = data.toString('utf-8', 4);
        var tokens = str.split(' ');

        if (tokens.length === 3 && tokens[0] === 'challenge' && tokens[1] === 'rcon') {
          _this._challengeToken = tokens[2].substr(0, tokens[2].length - 1).trim();
          _this.hasAuthed = true;

          _this.emit('auth');
        } else {
          _this.emit('response', str.substr(1, str.length - 2));
        }
      } else {
        _this.emit('error', new Error('Received malformed packet'));
      }
    };

    _this._tcpSocketOnData = function (data) {
      if (_this.outstandingData != null) {
        data = Buffer.concat([_this.outstandingData, data], _this.outstandingData.length + data.length);
        _this.outstandingData = null;
      }

      while (data.length) {
        var len = data.readInt32LE(0);
        if (!len) return;
        var id = data.readInt32LE(4);
        var type = data.readInt32LE(8);

        if (len >= 10 && data.length >= len + 4) {
          if (id === _this.rconId) {
            if (!_this.hasAuthed && type === PacketType.RESPONSE_AUTH) {
              _this.hasAuthed = true;

              _this.emit('auth');
            } else if (type === PacketType.RESPONSE_VALUE) {
              // Read just the body of the packet (truncate the last null byte)
              // See https://developer.valvesoftware.com/wiki/Source_RCON_Protocol for details
              var str = data.toString('utf8', 12, 12 + len - 10);

              if (str.charAt(str.length - 1) === '\n') {
                // Emit the response without the newline.
                str = str.substring(0, str.length - 1);
              }

              _this.emit('response', str);
            }
          } else {
            _this.emit('error', new Error('Authentication failed'));
          }

          data = data.slice(12 + len - 8);
        } else {
          // Keep a reference to the chunk if it doesn't represent a full packet
          _this.outstandingData = data;
          break;
        }
      }
    };

    _this.socketOnConnect = function () {
      _this.emit('connect');

      if (_this.tcp) {
        _this.send(_this.password, PacketType.AUTH);
      } else if (_this.challenge) {
        var str = 'challenge rcon\n';
        var sendBuf = Buffer.alloc(str.length + 4);
        sendBuf.writeInt32LE(-1, 0);
        sendBuf.write(str, 4);

        _this._sendSocket(sendBuf);
      } else {
        var _sendBuf = Buffer.alloc(5);

        _sendBuf.writeInt32LE(-1, 0);

        _sendBuf.writeUInt8(0, 4);

        _this._sendSocket(_sendBuf);

        _this.hasAuthed = true;

        _this.emit('auth');
      }
    };

    _this.socketOnEnd = function () {
      _this.emit('end');

      _this.hasAuthed = false;
    };

    options = options || {};
    _this.host = host;
    _this.port = port;
    _this.password = password;
    _this.rconId = options.id || 0x0012d4a6; // This is arbitrary in most cases

    _this.hasAuthed = false;
    _this.outstandingData = null;
    _this.tcp = options.tcp ? options.tcp : true;
    _this.challenge = options.challenge ? options.challenge : true;
    _this._challengeToken = '';
    EventEmitter.call(_assertThisInitialized(_this));
    return _this;
  }

  return Rcon;
}(EventEmitter);

export default Rcon;
//# sourceMappingURL=ts-rcon.esm.js.map
