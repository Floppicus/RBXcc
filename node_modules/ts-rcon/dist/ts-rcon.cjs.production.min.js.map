{"version":3,"file":"ts-rcon.cjs.production.min.js","sources":["../src/node-rcon.ts"],"sourcesContent":["import * as events from 'events';\nimport * as net from 'net';\nimport * as dgram from 'dgram';\nimport { Buffer } from 'buffer';\n\nconst PacketType = {\n  COMMAND: 0x02,\n  AUTH: 0x03,\n  RESPONSE_VALUE: 0x00,\n  RESPONSE_AUTH: 0x02,\n};\n\ninterface Options {\n  tcp?: boolean;\n  challenge?: boolean;\n  id?: number;\n}\n\nexport class Rcon extends events.EventEmitter {\n  private host: string;\n  private port: number;\n  private password: string;\n  private rconId: number;\n  private hasAuthed: boolean;\n  private outstandingData: Uint8Array | null;\n  private tcp: boolean;\n  private challenge: boolean;\n  private _challengeToken: string;\n  private _tcpSocket!: net.Socket;\n  private _udpSocket!: dgram.Socket;\n\n  constructor(host: string, port: number, password: string, options?: Options) {\n    super();\n    options = options || {};\n    this.host = host;\n    this.port = port;\n    this.password = password;\n    this.rconId = options.id || 0x0012d4a6; // This is arbitrary in most cases\n    this.hasAuthed = false;\n    this.outstandingData = null;\n    this.tcp = options.tcp ? options.tcp : true;\n    this.challenge = options.challenge ? options.challenge : true;\n    this._challengeToken = '';\n\n    events.EventEmitter.call(this);\n  }\n\n  public send = (data: string, cmd?: number, id?: number): void => {\n    let sendBuf: Buffer;\n    if (this.tcp) {\n      cmd = cmd || PacketType.COMMAND;\n      id = id || this.rconId;\n\n      const length = Buffer.byteLength(data);\n      sendBuf = Buffer.alloc(length + 14);\n      sendBuf.writeInt32LE(length + 10, 0);\n      sendBuf.writeInt32LE(id, 4);\n      sendBuf.writeInt32LE(cmd, 8);\n      sendBuf.write(data, 12);\n      sendBuf.writeInt16LE(0, length + 12);\n    } else {\n      if (this.challenge && !this._challengeToken) {\n        this.emit('error', new Error('Not authenticated'));\n        return;\n      }\n      let str = 'rcon ';\n      if (this._challengeToken) str += this._challengeToken + ' ';\n      if (this.password) str += this.password + ' ';\n      str += data + '\\n';\n      sendBuf = Buffer.alloc(4 + Buffer.byteLength(str));\n      sendBuf.writeInt32LE(-1, 0);\n      sendBuf.write(str, 4);\n    }\n    this._sendSocket(sendBuf);\n  };\n\n  private _sendSocket = (buf: Buffer) => {\n    if (this._tcpSocket) {\n      this._tcpSocket.write(buf.toString('binary'), 'binary');\n    } else if (this._udpSocket) {\n      this._udpSocket.send(buf, 0, buf.length, this.port, this.host);\n    }\n  };\n\n  public connect = (): void => {\n    if (this.tcp) {\n      this._tcpSocket = net.createConnection(this.port, this.host);\n      this._tcpSocket\n        .on('data', data => {\n          this._tcpSocketOnData(data);\n        })\n        .on('connect', () => {\n          this.socketOnConnect();\n        })\n        .on('error', err => {\n          this.emit('error', err);\n        })\n        .on('end', () => {\n          this.socketOnEnd();\n        });\n    } else {\n      this._udpSocket = dgram.createSocket('udp4');\n      this._udpSocket\n        .on('message', data => {\n          this._udpSocketOnData(data);\n        })\n        .on('listening', () => {\n          this.socketOnConnect();\n        })\n        .on('error', err => {\n          this.emit('error', err);\n        })\n        .on('close', () => {\n          this.socketOnEnd();\n        });\n      this._udpSocket.bind(0);\n    }\n  };\n\n  public disconnect = (): void => {\n    if (this._tcpSocket) this._tcpSocket.end();\n    if (this._udpSocket) this._udpSocket.close();\n  };\n\n  public setTimeout = (timeout: number, callback: () => void): void => {\n    if (!this._tcpSocket) return;\n    this._tcpSocket.setTimeout(timeout, () => {\n      this._tcpSocket.end();\n      if (callback) callback();\n    });\n  };\n\n  private _udpSocketOnData = (data: Buffer) => {\n    const a = data.readUInt32LE(0);\n    if (a === 0xffffffff) {\n      const str = data.toString('utf-8', 4);\n      const tokens = str.split(' ');\n      if (\n        tokens.length === 3 &&\n        tokens[0] === 'challenge' &&\n        tokens[1] === 'rcon'\n      ) {\n        this._challengeToken = tokens[2].substr(0, tokens[2].length - 1).trim();\n        this.hasAuthed = true;\n        this.emit('auth');\n      } else {\n        this.emit('response', str.substr(1, str.length - 2));\n      }\n    } else {\n      this.emit('error', new Error('Received malformed packet'));\n    }\n  };\n\n  private _tcpSocketOnData = (data: Buffer) => {\n    if (this.outstandingData != null) {\n      data = Buffer.concat(\n        [this.outstandingData, data],\n        this.outstandingData.length + data.length\n      );\n      this.outstandingData = null;\n    }\n\n    while (data.length) {\n      const len = data.readInt32LE(0);\n      if (!len) return;\n\n      const id = data.readInt32LE(4);\n      const type = data.readInt32LE(8);\n\n      if (len >= 10 && data.length >= len + 4) {\n        if (id === this.rconId) {\n          if (!this.hasAuthed && type === PacketType.RESPONSE_AUTH) {\n            this.hasAuthed = true;\n            this.emit('auth');\n          } else if (type === PacketType.RESPONSE_VALUE) {\n            // Read just the body of the packet (truncate the last null byte)\n            // See https://developer.valvesoftware.com/wiki/Source_RCON_Protocol for details\n            let str = data.toString('utf8', 12, 12 + len - 10);\n\n            if (str.charAt(str.length - 1) === '\\n') {\n              // Emit the response without the newline.\n              str = str.substring(0, str.length - 1);\n            }\n\n            this.emit('response', str);\n          }\n        } else {\n          this.emit('error', new Error('Authentication failed'));\n        }\n\n        data = data.slice(12 + len - 8);\n      } else {\n        // Keep a reference to the chunk if it doesn't represent a full packet\n        this.outstandingData = data;\n        break;\n      }\n    }\n  };\n\n  public socketOnConnect = (): void => {\n    this.emit('connect');\n\n    if (this.tcp) {\n      this.send(this.password, PacketType.AUTH);\n    } else if (this.challenge) {\n      const str = 'challenge rcon\\n';\n      const sendBuf = Buffer.alloc(str.length + 4);\n      sendBuf.writeInt32LE(-1, 0);\n      sendBuf.write(str, 4);\n      this._sendSocket(sendBuf);\n    } else {\n      const sendBuf = Buffer.alloc(5);\n      sendBuf.writeInt32LE(-1, 0);\n      sendBuf.writeUInt8(0, 4);\n      this._sendSocket(sendBuf);\n\n      this.hasAuthed = true;\n      this.emit('auth');\n    }\n  };\n\n  public socketOnEnd = (): void => {\n    this.emit('end');\n    this.hasAuthed = false;\n  };\n}\n"],"names":["host","port","password","options","data","cmd","id","sendBuf","_this","tcp","rconId","length","Buffer","byteLength","alloc","writeInt32LE","write","writeInt16LE","challenge","_challengeToken","emit","Error","str","_sendSocket","buf","_tcpSocket","toString","_udpSocket","send","net","on","_tcpSocketOnData","socketOnConnect","err","socketOnEnd","dgram","_udpSocketOnData","bind","end","close","timeout","callback","setTimeout","readUInt32LE","tokens","split","substr","trim","hasAuthed","outstandingData","concat","len","readInt32LE","type","charAt","substring","slice","writeUInt8","events","call"],"mappings":"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"}